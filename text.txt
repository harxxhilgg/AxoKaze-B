===============================================================================
BACKEND AUTHENTICATION ENDPOINTS & OPTIMAL FRONTEND IMPLEMENTATION
===============================================================================

üìç YOUR BACKEND ENDPOINTS
===============================================================================

1. REFRESH TOKEN ENDPOINT
   - URL: POST /api/auth/refresh-token
   - Type: Public route (no auth required)
   - Purpose: Get new access & refresh tokens
   - Expects: Refresh token from cookies (automatic)

2. LOGOUT ENDPOINT
   - URL: POST /api/auth/logout
   - Type: Protected route (requires auth)
   - Purpose: Clears tokens from DB and cookies
   - Action: Sets refreshToken & refreshTokenExpiry to undefined

3. GET PROFILE ENDPOINT
   - URL: GET /api/auth/get-profile
   - Type: Protected route
   - Purpose: Fetch current user data

===============================================================================
üéØ RECOMMENDED APPROACH: HYBRID (SECURITY + PERFORMANCE)
===============================================================================

‚úÖ BEST BALANCE OF SECURITY AND PERFORMANCE

Why This Approach?
------------------
‚úì Security: Validates session on app initialization
‚úì Performance: No repeated checks on every route change
‚úì Fresh Tokens: Auto-refresh mechanism handles expired tokens
‚úì User Experience: Fast navigation, no loading flickers
‚úì Real-time Security: Catches revoked/expired sessions immediately


===============================================================================
üì¶ STATE MANAGEMENT
===============================================================================

RECOMMENDATION: Keep Zustand (Option A)

Reasons:
--------
‚úì Already implemented in your project
‚úì Lighter than React Context (~1KB)
‚úì Better performance (no Context re-render issues)
‚úì Simpler API
‚úì Easy localStorage persistence
‚úì Perfect for auth state management


===============================================================================
üîê SESSION CHECK STRATEGY (HYBRID APPROACH)
===============================================================================

WHEN TO CHECK AUTH:
-------------------
1. ‚úÖ On app initialization (first load)
2. ‚úÖ After login/register
3. ‚úÖ When token refresh fails (401 error)
4. ‚ùå NOT on every route navigation

HOW IT WORKS:
-------------
1. User opens app ‚Üí Check auth ONCE
2. User navigates ‚Üí Trust existing auth state
3. API call made ‚Üí Axios interceptor checks token
4. Token expired ‚Üí Auto-refresh in background
5. Refresh fails ‚Üí Force logout & redirect to login


===============================================================================
üìù IMPLEMENTATION PLAN
===============================================================================

STEP 1: Setup Axios Instance with Interceptor
----------------------------------------------

// src/api/axiosInstance.js
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://your-backend-url/api', // Replace with your URL
  withCredentials: true, // ‚úÖ CRITICAL: Sends httpOnly cookies
  headers: {
    'Content-Type': 'application/json',
  },
});

// Response Interceptor - Handles Token Refresh
api.interceptors.response.use(
  (response) => response, // Success - pass through
  
  async (error) => {
    const originalRequest = error.config;

    // If 401 error and haven't retried yet
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // Attempt to refresh tokens
        await api.post('/auth/refresh-token');
        
        // Retry the original request with new tokens
        return api(originalRequest);
        
      } catch (refreshError) {
        // Refresh failed - user must re-login
        // Clear auth state and redirect
        if (typeof window !== 'undefined') {
          localStorage.removeItem('auth-storage'); // Zustand persist key
          window.location.href = '/login';
        }
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default api;


STEP 2: Create Auth Store (Zustand)
------------------------------------

// src/stores/authStore.js
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import api from '../api/axiosInstance';

const useAuthStore = create(
  persist(
    (set) => ({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      hasCheckedAuth: false,

      // Check authentication (call ONCE on app load)
      checkAuth: async () => {
        set({ isLoading: true });
        try {
          const response = await api.get('/auth/get-profile');
          set({
            user: response.data.user,
            isAuthenticated: true,
            hasCheckedAuth: true,
            isLoading: false,
          });
        } catch (error) {
          set({
            user: null,
            isAuthenticated: false,
            hasCheckedAuth: true,
            isLoading: false,
          });
        }
      },

      // Login
      login: async (email, password) => {
        const response = await api.post('/auth/login', { email, password });
        return response.data; // Returns { requiresOtp: true, email }
      },

      // Verify OTP
      verifyOtp: async (email, otp) => {
        const response = await api.post('/auth/verify-otp', { email, otp });
        set({
          user: response.data.user,
          isAuthenticated: true,
        });
        return response.data;
      },

      // Logout
      logout: async () => {
        try {
          await api.post('/auth/logout');
        } catch (error) {
          console.error('Logout error:', error);
        } finally {
          set({
            user: null,
            isAuthenticated: false,
          });
        }
      },

      // Update user data (after profile update)
      setUser: (user) => set({ user, isAuthenticated: true }),
    }),
    {
      name: 'auth-storage', // localStorage key
      partialize: (state) => ({
        // Only persist user and isAuthenticated
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);

export default useAuthStore;


STEP 3: Check Auth on App Initialization
-----------------------------------------

// App.jsx or main.jsx
import { useEffect } from 'react';
import useAuthStore from './stores/authStore';

function App() {
  const { checkAuth, hasCheckedAuth } = useAuthStore();

  // ‚úÖ Check auth ONCE when app loads
  useEffect(() => {
    if (!hasCheckedAuth) {
      checkAuth();
    }
  }, [checkAuth, hasCheckedAuth]);

  return (
    <div>
      {/* Your routes */}
    </div>
  );
}

export default App;


STEP 4: Protected Route Component
----------------------------------

// src/components/ProtectedRoute.jsx
import { Navigate } from 'react-router-dom';
import useAuthStore from '../stores/authStore';

function ProtectedRoute({ children }) {
  const { isAuthenticated, isLoading } = useAuthStore();

  // Show loading while checking auth
  if (isLoading) {
    return <div>Loading...</div>;
  }

  // Redirect to login if not authenticated
  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  // User is authenticated, render the page
  return children;
}

export default ProtectedRoute;


STEP 5: Use Protected Routes
-----------------------------

// In your router setup
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import ProtectedRoute from './components/ProtectedRoute';
import Dashboard from './pages/Dashboard';
import Login from './pages/Login';

function AppRouter() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />
        
        <Route
          path="/dashboard"
          element={
            <ProtectedRoute>
              <Dashboard />
            </ProtectedRoute>
          }
        />
        
        {/* More protected routes */}
      </Routes>
    </BrowserRouter>
  );
}


STEP 6: Login Component Example
--------------------------------

// src/pages/Login.jsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import useAuthStore from '../stores/authStore';

function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [otp, setOtp] = useState('');
  const [showOtpInput, setShowOtpInput] = useState(false);
  const [error, setError] = useState('');
  
  const { login, verifyOtp } = useAuthStore();
  const navigate = useNavigate();

  const handleLogin = async (e) => {
    e.preventDefault();
    try {
      const data = await login(email, password);
      if (data.requiresOtp) {
        setShowOtpInput(true);
      }
    } catch (err) {
      setError(err.response?.data?.message || 'Login failed');
    }
  };

  const handleVerifyOtp = async (e) => {
    e.preventDefault();
    try {
      await verifyOtp(email, otp);
      navigate('/dashboard'); // Success!
    } catch (err) {
      setError(err.response?.data?.message || 'OTP verification failed');
    }
  };

  if (showOtpInput) {
    return (
      <form onSubmit={handleVerifyOtp}>
        <input
          type="text"
          placeholder="Enter OTP"
          value={otp}
          onChange={(e) => setOtp(e.target.value)}
        />
        <button type="submit">Verify OTP</button>
        {error && <p>{error}</p>}
      </form>
    );
  }

  return (
    <form onSubmit={handleLogin}>
      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button type="submit">Login</button>
      {error && <p>{error}</p>}
    </form>
  );
}

export default Login;


===============================================================================
üîÑ HOW TOKEN REFRESH WORKS (AUTOMATIC)
===============================================================================

FLOW:
-----
1. User makes API request (e.g., GET /api/auth/get-profile)
2. Access token is expired (15 minutes passed)
3. Backend returns 401 Unauthorized
4. Axios interceptor catches the 401 error
5. Interceptor calls POST /api/auth/refresh-token
6. Backend validates refresh token (good for 7 days)
7. Backend issues NEW access + refresh tokens
8. Tokens stored in httpOnly cookies automatically
9. Interceptor retries the original request
10. Original request succeeds with new access token

USER EXPERIENCE:
----------------
‚úÖ Completely transparent
‚úÖ No loading states
‚úÖ No interruption
‚úÖ User stays logged in for 7 days (with activity)


===============================================================================
‚è±Ô∏è SESSION TIMELINE
===============================================================================

Login ‚Üí User stays logged in for 7 days (with periodic auto-refreshes)

0 min       - Login successful, tokens issued
15 min      - Access token expires ‚Üí Auto-refresh ‚Üí New tokens
30 min      - Access token expires ‚Üí Auto-refresh ‚Üí New tokens
45 min      - Access token expires ‚Üí Auto-refresh ‚Üí New tokens
... continues every ~15 minutes when user is active ...
7 days      - Refresh token expires ‚Üí Must login again

NOTE: Your backend ALREADY implements sliding sessions!
Every refresh extends the 7-day window, so active users stay logged in.


===============================================================================
üîí SECURITY FEATURES
===============================================================================

‚úÖ httpOnly Cookies
   - Tokens stored in httpOnly cookies
   - JavaScript cannot access them
   - Prevents XSS attacks

‚úÖ Secure Flag (Production)
   - Cookies only sent over HTTPS
   - Prevents man-in-the-middle attacks

‚úÖ SameSite Protection
   - 'none' in production for cross-origin
   - 'lax' in development
   - Prevents CSRF attacks

‚úÖ Token Rotation
   - New refresh token on every refresh
   - Old tokens become invalid
   - Prevents token reuse

‚úÖ Database Token Storage
   - Refresh tokens stored in DB
   - Can be revoked server-side
   - Immediate logout capability

‚úÖ Short-lived Access Tokens
   - 15-minute lifespan
   - Limits exposure window
   - Frequent rotation


===============================================================================
‚ö° PERFORMANCE OPTIMIZATIONS
===============================================================================

1. Single Auth Check
   ‚úì Only check on app initialization
   ‚úì No repeated checks on route changes
   ‚úì Faster navigation

2. Optimistic UI
   ‚úì Trust auth state until proven invalid
   ‚úì No loading spinners on every page
   ‚úì Better user experience

3. Background Token Refresh
   ‚úì Happens automatically during API calls
   ‚úì User never sees it
   ‚úì No dedicated refresh polling

4. LocalStorage Persistence
   ‚úì Auth state persists across page refreshes
   ‚úì No need to re-check on every reload
   ‚úì Instant app load

5. Minimal DB Queries
   ‚úì No repeated profile fetches
   ‚úì Only refresh when needed
   ‚úì Lower server load


===============================================================================
üö® IMPORTANT CORS SETUP
===============================================================================

Your backend already has correct CORS setup:

app.use(cors({
  origin: [
    "http://localhost:5173",
    "http://localhost:3000", 
    "https://axokaze.vercel.app"
  ],
  credentials: true, // ‚úÖ CRITICAL for cookies
}));

Frontend must use:
- axios: withCredentials: true ‚úÖ
- fetch: credentials: 'include' ‚úÖ


===============================================================================
üìã CHECKLIST
===============================================================================

Backend (Already Done ‚úÖ):
  ‚úÖ Refresh token endpoint (/api/auth/refresh-token)
  ‚úÖ Logout endpoint (/api/auth/logout)
  ‚úÖ CORS with credentials enabled
  ‚úÖ httpOnly cookies
  ‚úÖ Token rotation
  ‚úÖ Sliding sessions (refresh extends expiry)

Frontend (To Implement):
  ‚¨ú Setup axios instance with withCredentials: true
  ‚¨ú Add response interceptor for auto token refresh
  ‚¨ú Create Zustand store with checkAuth function
  ‚¨ú Call checkAuth ONCE on app mount
  ‚¨ú Create ProtectedRoute component
  ‚¨ú Wrap protected pages with ProtectedRoute
  ‚¨ú Remove auth checks from individual route components


===============================================================================
üéØ SUMMARY
===============================================================================

APPROACH: Hybrid (Security + Performance)

SESSION DURATION:
- Active user: 7 days (with auto-refresh every 15 min)
- Inactive user: Logged out after 7 days of no activity

STRATEGY:
1. Check auth ONCE on app initialization
2. Trust auth state during navigation
3. Auto-refresh tokens in background via interceptor
4. Force logout only when refresh fails

STATE MANAGEMENT: Zustand (keep what you have)

RESULT:
‚úÖ Fast navigation (no repeated API calls)
‚úÖ Secure (validates on init + auto-refresh)
‚úÖ Great UX (no loading flickers)
‚úÖ Fresh tokens (automatic rotation)
‚úÖ Real-time security (catches revoked sessions)

This is the OPTIMAL approach for modern web applications!

===============================================================================